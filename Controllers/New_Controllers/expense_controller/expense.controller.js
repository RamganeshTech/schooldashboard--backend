import mongoose from "mongoose";
import { ExpenseModel } from "../../../Models/New_Model/expense_model/expense.model.js";
import { uploadFileToS3New } from "../../../Utils/s4UploadsNew.js";
import { archiveData } from "../deleteArchieve_controller/deleteArchieve.controller.js";
import SchoolModel from "../../../Models/New_Model/SchoolModel/shoolModel.model.js";
import { createLedgerEntry } from "../financeLedger_controller/financeLedger.controller.js";
import { createAuditLog } from "../audit_controllers/audit.controllers.js";

const processFiles = async (filesArray) => {
    if (!filesArray || filesArray.length === 0) return [];
    return await Promise.all(
        filesArray.map(async (file) => {
            const uploadData = await uploadFileToS3New(file);
            const type = file.mimetype.startsWith("image") ? "image" : "pdf";
            return {
                url: uploadData.url,
                key: uploadData.key,
                type: type,
                originalName: file.originalname,
                uploadedAt: new Date()
            };
        })
    );
};


export const addExpense = async (req, res) => {
    try {
        let {
            amount, category, paymentMode,
            academicYear, date,
            chequeNumber, bankName, remarks, schoolId
        } = req.body;

        const userRole = req.user.role; // Assuming set by auth middleware

        if (!amount || !schoolId || !category || !paymentMode) {
            return res.status(400).json({
                ok: false,
                message: "amount , schoolId , category, paymentMode is required"
            });
        }

        // -------------------------------------------------
        // 1. ROLE-BASED FILE VALIDATION
        // -------------------------------------------------

        // Get files safely (might be undefined if no files uploaded)
        const billFiles = req.files && req.files["billProof"] ? req.files["billProof"] : [];
        const workFiles = req.files && req.files["workProof"] ? req.files["workProof"] : [];

        // RULE: If NOT Correspondent, Bill is MANDATORY
        if (userRole !== "correspondent") {
            if (billFiles.length === 0) {
                return res.status(400).json({
                    ok: false,
                    message: "Bill/Invoice upload is MANDATORY for this user role."
                });
            }
        }

        // -------------------------------------------------
        // 2. PAYMENT MODE VALIDATION
        // -------------------------------------------------
        let chequeData = {};
        if (paymentMode === "cheque") {
            if (!chequeNumber || !bankName) {
                return res.status(400).json({
                    ok: false,

                    message: "Cheque Number and Bank Name are required for Cheque payments."
                });
            }
            chequeData = { chequeNumber, bankName };
        }

        if (!academicYear) {
            // // 1. Get Academic Year (Source of Truth)
            const schoolDoc = await SchoolModel.findById(schoolId)
            academicYear = schoolDoc?.currentAcademicYear;

            if (!academicYear) {
                return res.status(500).json({
                    ok: false,
                    message: "Current Academic year is not set for the school , either set in school department or else provide the academic year"
                });
            }
        }

        // Process both arrays (Bills and Work Photos)
        const uploadedBills = await processFiles(billFiles);
        const uploadedWorkPhotos = await processFiles(workFiles);



        // -------------------------------------------------
        // 4. SAVE TO DATABASE
        // -------------------------------------------------
        const newExpense = new ExpenseModel({
            //   expenseNo: undefined, // Will be generated by Pre-Hook (EXP-001)
            schoolId,
            amount,
            academicYear,
            date,
            category,
            paymentMode,
            remarks,
            chequeDetails: chequeData,

            // Save arrays of file objects
            bill: uploadedBills,
            workPhoto: uploadedWorkPhotos,

            recordedBy: req.user._id,
            verificationStatus: "pending" // Default status
        });

        await newExpense.save();



        // ---------------------------------------------------------
        // 7. FINANCE LEDGER INTEGRATION (Money Out)
        // ---------------------------------------------------------

        // Determine Account Type

        await createLedgerEntry({
            schoolId,
            academicYear,
            transactionType: "DEBIT", // Expense = Debit
            amount: Number(amount),
            date: newExpense.date || new Date(),
            referenceModel: "ExpenseModel",
            referenceId: newExpense._id,
            category,
            section: "expense",
            paymentMode,
            description: remarks || `Expense for ${category}`,
            createdBy: req.user._id
        });

        // ---------------------------------------------------------

         await createAuditLog(req, {
            action: "create",
            module: "expense",
            targetId: newExpense?._id,
            description: `expense created (${newExpense._id})`,
            status: "success"
        });

        res.status(201).json({
            ok: true,
            message: "Expense recorded successfully.",
            data: newExpense,
        });

    } catch (error) {
        console.error("Add Expense Error:", error);
        res.status(500).json({ message: "Failed to record expense", error: error.message });
    }
};



export const getExpenseById = async (req, res) => {
    try {
        const { id } = req.params;

        // 1. Validate ObjectId
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({
                ok: false,
                message: "Invalid expense ID",
            });
        }

        // 2. Find expense
        const expense = await ExpenseModel.findById(id)
            .populate("schoolId", "name _id")
            .populate("recordedBy", "userName role _id");

        // 3. Not found
        if (!expense) {
            return res.status(404).json({
                ok: false,
                message: "Expense not found",
            });
        }

        // 4. Success
        res.status(200).json({
            ok: true,
            data: expense,
        });
    } catch (error) {
        console.error("Get Expense By ID Error:", error);
        res.status(500).json({
            ok: false,
            message: "Failed to fetch expense",
        });
    }
};


export const getAllExpenses = async (req, res) => {
    try {
        const {
            schoolId,
            minAmount,
            maxAmount,
            fromDate,
            toDate,
            page = 1,
            limit = 10
        } = req.query;

        if (!schoolId) {
            return res.status(400).json({
                ok: false,
                message: "schoolId is required in query params"
            });
        }

        const skip = (parseInt(page) - 1) * parseInt(limit);

        // 1. Build Query
        const query = { schoolId: new mongoose.Types.ObjectId(schoolId) };

        // --- FILTER: AMOUNT RANGE ---
        if (minAmount || maxAmount) {
            query.amount = {};
            if (minAmount) {
                query.amount.$gte = Number(minAmount); // Greater than or equal
            }
            if (maxAmount) {
                query.amount.$lte = Number(maxAmount); // Less than or equal
            }
        }

        // --- FILTER: DATE RANGE ---
        if (fromDate || toDate) {
            query.date = {};
            if (fromDate) {
                // Start of the day (00:00:00)
                query.date.$gte = new Date(fromDate);
            }
            if (toDate) {
                // End of the day (23:59:59) to include all expenses of that specific date
                const endDate = new Date(toDate);
                endDate.setHours(23, 59, 59, 999);
                query.date.$lte = endDate;
            }
        }

        // 2. Fetch Data with Pagination
        const expenses = await ExpenseModel.find(query)
            .populate("recordedBy", "userName role") // Show who added it
            .sort({ createdAt: -1 }) // Latest first
            .skip(skip)
            .limit(limit);

        // 3. Get Total Count (for frontend pagination)
        const totalExpenses = await ExpenseModel.countDocuments(query);

        res.status(200).json({
            ok: true,
            message: "Expenses fetched successfully",
            data: expenses,
            pagination: {
                total: totalExpenses,
                currentPage: page,
                totalPages: Math.ceil(totalExpenses / limit),
                limit: limit
            }
        });

    } catch (error) {
        console.error("Get All Expenses Error:", error);
        res.status(500).json({ ok: false, message: "Failed to fetch expenses", error: error.message });
    }
};


export const deleteExpense = async (req, res) => {
    try {
        const { id } = req.params;


        // 2. Find and Delete
        const deletedExpense = await ExpenseModel.findByIdAndDelete(id);




        // console.log("deletedOne", deletedOne)

        if (!deletedExpense) {
            return res.status(404).json({
                ok: false,
                message: "Expense not found"
            });
        }

        // 2. CALL THE ARCHIVE UTILITY
        const deletedOne = await archiveData({
            schoolId: deletedExpense.schoolId,
            category: "expense",
            originalId: deletedExpense._id,
            deletedData: deletedExpense.toObject(), // Convert Mongoose doc to plain object
            deletedBy: req.user._id || null,
            reason: null, // Optional reason from body
        });

        await createAuditLog(req, {
            action: "delete",
            module: "expense",
            targetId: id,
            description: `expense got deleted (${id})`,
            status: "success"
        });


        // TODO: If you have a DeletedExpenseArchiveModel, you should create that entry here 
        // before deleting, or use Soft Delete (isDeleted: true) instead of findByIdAndDelete.

        res.status(200).json({
            ok: true,
            message: "Expense deleted successfully",
            data: deletedExpense // Returning what was deleted
        });

    } catch (error) {
        console.error("Delete Expense Error:", error);
        res.status(500).json({ ok: false, message: "Failed to delete expense", error: error.message });
    }
};


export const updateExpense = async (req, res) => {
    try {
        const { id } = req.params;
        let {
            schoolId,
            amount, category, paymentMode,
            academicYear,
            chequeNumber, bankName, remarks
        } = req.body;

        if (!schoolId) {
            return res.status(400).json({
                ok: false,
                message: "schoolId is required"
            });
        }

        const userRole = req.user.role;

        // 1. Role Restriction
        if (userRole !== "correspondent") {
            return res.status(403).json({
                ok: false,
                message: "Access Denied. Only Correspondent can update expenses."
            });
        }

        // 2. Find Existing Expense
        const expense = await ExpenseModel.findById(id);
        if (!expense) {
            return res.status(404).json({ ok: false, message: "Expense not found" });
        }

        // 3. Handle Cheque Validation (If payment mode changes or is updated)
        let chequeData = expense.chequeDetails; // Default to existing
        const modeToCheck = paymentMode || expense.paymentMode; // New mode or existing

        if (modeToCheck === "cheque") {
            // If updating to cheque, ensure we have details either in body or existing DB
            const cNum = chequeNumber || expense.chequeDetails?.chequeNumber;
            const bName = bankName || expense.chequeDetails?.bankName;

            if (!cNum || !bName) {
                return res.status(400).json({
                    ok: false,
                    message: "Cheque Number and Bank Name are required for Cheque payments."
                });
            }
            chequeData = { chequeNumber: cNum, bankName: bName };
        } else {
            // If switching to Cash/UPI, clear cheque details
            chequeData = {};
        }

        // 4. Process New Files (If any)
        const newBillFiles = req.files && req.files["billProof"] ? req.files["billProof"] : [];
        const newWorkFiles = req.files && req.files["workProof"] ? req.files["workProof"] : [];

        if (!academicYear) {
            // // 1. Get Academic Year (Source of Truth)
            const schoolDoc = await SchoolModel.findById(schoolId)
            academicYear = schoolDoc?.currentAcademicYear;

            if (!academicYear) {
                return res.status(500).json({
                    ok: false,
                    message: "Current Academic year is not set for the school , either set in school department or else provide the academic year"
                });
            }
        }

        const uploadedBills = await processFiles(newBillFiles);
        const uploadedWorkPhotos = await processFiles(newWorkFiles);

        // 5. Update Fields
        // We use || to keep existing values if not provided in update
        if (amount) expense.amount = amount;
        if (category) expense.category = category;
        if (paymentMode) expense.paymentMode = paymentMode;
        if (remarks) expense.remarks = remarks;
        if (academicYear) expense.academicYear = academicYear;
        expense.chequeDetails = chequeData;

        // Append new files to existing arrays
        if (uploadedBills.length > 0) {
            expense.bill = [...expense.bill, ...uploadedBills];
        }
        if (uploadedWorkPhotos.length > 0) {
            expense.workPhoto = [...expense.workPhoto, ...uploadedWorkPhotos];
        }

        // 6. Save
        await expense.save();



        // ---------------------------------------------------------
        // 6. FINANCE LEDGER UPDATE (Cancel Old -> Create New)
        // ---------------------------------------------------------

        await createLedgerEntry({
            schoolId: expense.schoolId,
            academicYear: expense.academicYear,
            transactionType: "DEBIT",
            amount: Number(expense.amount),
            date: new Date(), // Date of Update
            referenceModel: "ExpenseModel",
            referenceId: expense._id,
            category: expense.category,
            section: "expense",
            paymentMode: expense.paymentMode,
            description: expense.remarks || "Updated Expense Entry",
            createdBy: req.user._id
        });
        // ---------------------------------------------------------

        await createAuditLog(req, {
            action: "edit",
            module: "expense",
            targetId: expense._id,
            description: `updated the expense data for this id (${expense._id})`,
            status: "success"
        });


        res.status(200).json({
            ok: true,
            message: "Expense updated successfully",
            data: expense
        });

    } catch (error) {
        console.error("Update Expense Error:", error);
        res.status(500).json({ ok: false, message: "Failed to update expense", error: error.message });
    }
};


export const updateExpenseStatus = async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = req.body; // Expecting "verified" or "pending"

        // 1. Role Restriction
        // Usually, the person who created the expense (Accountant) should not be able to verify it.
        // Allowed: Correspondent, Principal
        // if (req.user.role !== "correspondent" && req.user.role !== "principal") {
        //     return res.status(403).json({
        //         ok: false,
        //         message: "Access Denied. Only Correspondent or Principal can verify expenses."
        //     });
        // }

        // 2. Input Validation
        // Must match the enum in your ExpenseModel
        const validStatuses = ["pending", "verified"];

        if (!status || !validStatuses.includes(status)) {
            return res.status(400).json({
                ok: false,
                message: `Invalid status. Allowed values are: ${validStatuses.join(", ")}`
            });
        }

        // 3. Find and Update
        const updatedExpense = await ExpenseModel.findByIdAndUpdate(
            id,
            { verificationStatus: status },
            { new: true } // Return the updated document immediately
        );

        if (!updatedExpense) {
            return res.status(404).json({
                ok: false,
                message: "Expense not found"
            });
        }


        await createAuditLog(req, {
            action: "edit",
            module: "expense",
            targetId: updatedExpense._id,
            description: `updated the expense status for this id (${updatedExpense._id})`,
            status: "success"
        });
        res.status(200).json({
            ok: true,
            message: `Expense marked as ${status.toUpperCase()} successfully.`,
            data: updatedExpense
        });

    } catch (error) {
        console.error("Update Status Error:", error);
        res.status(500).json({
            ok: false,
            message: "Failed to update status",
            error: error.message
        });
    }
};



export const deleteProof = async (req, res) => {
    try {
        const { expenseId, proofId, type } = req.body; // type must be 'bill' or 'workPhoto'

        // 1. Basic Validation
        if (!expenseId || !proofId || !type) {
            return res.status(400).json({
                ok: false,
                message: "expenseId, proofId, and type ('bill' or 'workPhoto') are required."
            });
        }

        if (!['bill', 'workPhoto'].includes(type)) {
            return res.status(400).json({ ok: false, message: "Type must be 'bill' or 'workPhoto'" });
        }

        // 2. Find the Expense
        const expense = await ExpenseModel.findById(expenseId);
        if (!expense) {
            return res.status(404).json({ ok: false, message: "Expense not found" });
        }

        // // 3. Authorization Check
        // // Usually only Correspondent can delete, or maybe the creator if strictly needed
        // if (req.user.role !== "correspondent") {
        //      return res.status(403).json({ ok: false, message: "Access Denied. Only Correspondent can delete proofs." });
        // }

        // 4. Find the Proof in the Array
        // We look inside expense.bill or expense.workPhoto
        const proofArray = expense[type]; // Access array dynamically

        // Find index of the file with this ID (assuming sub-docs have _ids, otherwise use key)
        // Since we didn't explicitly set _id:true in schema, check if your objects have _id. 
        // If not, pass 'key' instead of 'proofId' in body. 
        // Assuming here we use the S3 Key as the unique identifier if no _id exists.

        // Let's assume we identify by S3 KEY because it's definitely unique
        // Change: pass 'fileKey' in body instead of proofId if subdocs don't have IDs

        // OPTION A: Using KEY (Safest)
        // const fileIndex = proofArray.findIndex(item => item.key === proofId); // treating proofId as key here

        // OPTION B: Using _id (Only if your schema allows subdoc IDs)
        const fileIndex = proofArray.findIndex(item => item._id.toString() === proofId);

        if (fileIndex === -1) {
            return res.status(404).json({ ok: false, message: "File not found in this expense." });
        }


        // 5. Delete from S3
        // const fileToDelete = proofArray[fileIndex];
        // await deleteFileFromS3(fileToDelete.key);

        // 6. Remove from Database Array
        proofArray.splice(fileIndex, 1);

        // IMPORTANT: If 'bill' is mandatory for others but Correspondent is deleting, 
        // make sure you don't break your own rules. Since this is 'delete', we assume it's allowed.

        await expense.save();

        await createAuditLog(req, {
            action: "edit",
            module: "expense",
            targetId: expenseId,
            description: `proof deleted for this expense id (${expenseId})`,
            status: "success"
        });

        res.status(200).json({
            ok: true,
            message: "Proof file deleted successfully",
            data: expense // Return updated object
        });

    } catch (error) {
        console.error("Delete Proof Error:", error);
        res.status(500).json({ ok: false, message: "Failed to delete proof", error: error.message });
    }
};